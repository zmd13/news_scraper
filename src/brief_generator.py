"""Template-based Brief Generator for Healthcare News"""
from datetime import datetime
from typing import List, Dict


class BriefGenerator:
    """Generates formatted briefs from news articles"""

    def __init__(self, industry: str = "Healthcare"):
        """
        Initialize the brief generator

        Args:
            industry: Industry name for the brief title
        """
        self.industry = industry

    def generate_markdown_brief(self, articles: List[Dict]) -> str:
        """
        Generate a markdown-formatted brief

        Args:
            articles: List of article dictionaries

        Returns:
            Formatted markdown string
        """
        if not articles:
            return self._generate_empty_brief()

        brief = []

        # Header
        brief.append(f"# {self.industry} News Brief")
        brief.append(f"**Generated:** {datetime.now().strftime('%B %d, %Y at %I:%M %p')}")
        brief.append(f"**Articles Found:** {len(articles)}")
        brief.append("\n---\n")

        # Executive Summary
        brief.append("## Executive Summary\n")
        brief.append(self._generate_executive_summary(articles))
        brief.append("\n---\n")

        # Key Topics
        brief.append("## Key Topics\n")
        brief.append(self._generate_key_topics(articles))
        brief.append("\n---\n")

        # Detailed Articles
        brief.append("## Detailed News Items\n")
        for idx, article in enumerate(articles, 1):
            brief.append(self._format_article_markdown(article, idx))
            brief.append("")

        # Footer
        brief.append("\n---\n")
        brief.append("*This brief was automatically generated by the News Scraper*")

        return "\n".join(brief)

    def generate_text_brief(self, articles: List[Dict]) -> str:
        """
        Generate a plain text brief

        Args:
            articles: List of article dictionaries

        Returns:
            Formatted text string
        """
        if not articles:
            return self._generate_empty_brief(format_type="text")

        brief = []

        # Header
        brief.append("=" * 70)
        brief.append(f"{self.industry.upper()} NEWS BRIEF")
        brief.append("=" * 70)
        brief.append(f"Generated: {datetime.now().strftime('%B %d, %Y at %I:%M %p')}")
        brief.append(f"Articles Found: {len(articles)}")
        brief.append("=" * 70)
        brief.append("")

        # Executive Summary
        brief.append("EXECUTIVE SUMMARY")
        brief.append("-" * 70)
        brief.append(self._generate_executive_summary(articles))
        brief.append("")

        # Key Topics
        brief.append("KEY TOPICS")
        brief.append("-" * 70)
        brief.append(self._generate_key_topics(articles, format_type="text"))
        brief.append("")

        # Detailed Articles
        brief.append("DETAILED NEWS ITEMS")
        brief.append("-" * 70)
        for idx, article in enumerate(articles, 1):
            brief.append(self._format_article_text(article, idx))
            brief.append("")

        # Footer
        brief.append("=" * 70)
        brief.append("This brief was automatically generated by the News Scraper")
        brief.append("=" * 70)

        return "\n".join(brief)

    def _generate_executive_summary(self, articles: List[Dict]) -> str:
        """Generate an executive summary from articles"""
        summary_parts = []

        # Count articles by source
        sources = {}
        for article in articles:
            source = article['source']
            sources[source] = sources.get(source, 0) + 1

        summary_parts.append(
            f"This brief covers {len(articles)} significant news items "
            f"from the past 24 hours across {len(sources)} sources."
        )

        # Identify most common themes (simple keyword frequency)
        keywords = {}
        for article in articles:
            text = f"{article['title']} {article['description']}".lower()
            for word in ['shared savings', 'aco', 'risk', 'fraud', 'medicare', 'cms', 'milliman', 'analytics']:
                if word in text:
                    keywords[word] = keywords.get(word, 0) + 1

        if keywords:
            top_keywords = sorted(keywords.items(), key=lambda x: x[1], reverse=True)[:3]
            themes = [kw[0].title() for kw in top_keywords]
            summary_parts.append(f"Key themes include: {', '.join(themes)}.")

        return " ".join(summary_parts)

    def generate_html_brief(self, articles: List[Dict]) -> str:
        """
        Generate an HTML-formatted brief

        Args:
            articles: List of article dictionaries

        Returns:
            Formatted HTML string
        """
        if not articles:
            return self._generate_empty_brief(format_type="html")

        html = []

        # HTML header
        html.append("<!DOCTYPE html>")
        html.append("<html lang='en'>")
        html.append("<head>")
        html.append("<meta charset='UTF-8'>")
        html.append("<meta name='viewport' content='width=device-width, initial-scale=1.0'>")
        html.append(f"<title>{self.industry} News Brief</title>")
        html.append("<style>")
        html.append(self._get_html_styles())
        html.append("</style>")
        html.append("</head>")
        html.append("<body>")

        # Content
        html.append("<div class='container'>")
        html.append(f"<h1>{self.industry} News Brief</h1>")
        html.append(f"<p class='meta'>Generated: {datetime.now().strftime('%B %d, %Y at %I:%M %p')} | Articles Found: {len(articles)}</p>")

        # Executive Summary
        html.append("<h2>Executive Summary</h2>")
        html.append(f"<p>{self._generate_executive_summary(articles)}</p>")

        # Key Topics
        html.append("<h2>Key Topics</h2>")
        html.append(self._generate_key_topics(articles, format_type="html"))

        # Detailed Articles
        html.append("<h2>Detailed News Items</h2>")
        for idx, article in enumerate(articles, 1):
            html.append(self._format_article_html(article, idx))

        # Footer
        html.append("<footer>This brief was automatically generated by the News Scraper</footer>")
        html.append("</div>")
        html.append("</body>")
        html.append("</html>")

        return "\n".join(html)

    def _generate_key_topics(self, articles: List[Dict], format_type: str = "markdown") -> str:
        """Generate a list of key topics"""
        topics = []

        for article in articles[:5]:  # Top 5 articles
            topic = f"{article['title']} ({article['source']})"
            topics.append(topic)

        if format_type == "html":
            return "<ul>" + "".join([f"<li>{topic}</li>" for topic in topics]) + "</ul>"
        elif format_type == "text":
            return "\n".join([f"  • {topic}" for topic in topics])
        else:  # markdown
            return "\n".join([f"- {topic}" for topic in topics])

    def _format_article_markdown(self, article: Dict, index: int) -> str:
        """Format a single article in markdown"""
        formatted = []
        formatted.append(f"### {index}. {article['title']}")
        formatted.append(f"**Source:** {article['source']} | **Published:** {article['published'].strftime('%b %d, %Y %I:%M %p')}")
        formatted.append(f"\n{article['description']}")
        formatted.append(f"\n[Read More]({article['link']})")
        return "\n".join(formatted)

    def _format_article_text(self, article: Dict, index: int) -> str:
        """Format a single article in plain text"""
        formatted = []
        formatted.append(f"{index}. {article['title']}")
        formatted.append(f"   Source: {article['source']} | Published: {article['published'].strftime('%b %d, %Y %I:%M %p')}")
        formatted.append(f"\n   {article['description']}")
        formatted.append(f"\n   Link: {article['link']}")
        return "\n".join(formatted)

    def _format_article_html(self, article: Dict, index: int) -> str:
        """Format a single article in HTML"""
        html = []
        html.append("<div class='article'>")
        html.append(f"<h3>{index}. {article['title']}</h3>")
        html.append(f"<p class='meta'>Source: {article['source']} | Published: {article['published'].strftime('%b %d, %Y %I:%M %p')}</p>")
        html.append(f"<p>{article['description']}</p>")
        html.append(f"<a href='{article['link']}' target='_blank'>Read More →</a>")
        html.append("</div>")
        return "\n".join(html)

    def _get_html_styles(self) -> str:
        """Get CSS styles for HTML output"""
        return """
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            line-height: 1.6;
            color: #333;
            max-width: 900px;
            margin: 0 auto;
            padding: 20px;
            background: #f5f5f5;
        }
        .container {
            background: white;
            padding: 40px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        h1 {
            color: #2c3e50;
            border-bottom: 3px solid #3498db;
            padding-bottom: 10px;
        }
        h2 {
            color: #34495e;
            margin-top: 30px;
            border-bottom: 2px solid #ecf0f1;
            padding-bottom: 8px;
        }
        h3 {
            color: #2980b9;
        }
        .meta {
            color: #7f8c8d;
            font-size: 0.9em;
        }
        .article {
            margin: 20px 0;
            padding: 20px;
            background: #f8f9fa;
            border-left: 4px solid #3498db;
            border-radius: 4px;
        }
        .article h3 {
            margin-top: 0;
        }
        a {
            color: #3498db;
            text-decoration: none;
        }
        a:hover {
            text-decoration: underline;
        }
        footer {
            margin-top: 40px;
            padding-top: 20px;
            border-top: 1px solid #ecf0f1;
            text-align: center;
            color: #7f8c8d;
            font-size: 0.9em;
        }
        ul {
            list-style-type: none;
            padding-left: 0;
        }
        ul li {
            padding: 8px 0;
            border-bottom: 1px solid #ecf0f1;
        }
        ul li:before {
            content: "→ ";
            color: #3498db;
            font-weight: bold;
        }
        """

    def generate_categorized_html_brief(self, articles: List[Dict]) -> str:
        """
        Generate an HTML-formatted brief with articles grouped by category

        Args:
            articles: List of article dictionaries with 'category' key

        Returns:
            Formatted HTML string with categorized sections
        """
        if not articles:
            return self._generate_empty_brief(format_type="html")

        # Define category order (user's preference: 1-10, then Other)
        category_order = [
            "Industry Analysis",                         # 1
            "Risk Adjustment & Actuarial",              # 2
            "CMS Rules & Policy",                        # 3
            "Value-Based Care Models",                   # 4
            "Technology & Platforms",                    # 5
            "Provider Contracts & Disputes",             # 6
            "Medicare Advantage Market",                 # 7
            "M&A and Partnerships",                      # 8
            "ACO Performance",                           # 9
            "Company Earnings & Financial Performance"   # 10
        ]

        # Group articles by category
        from collections import defaultdict
        categorized = defaultdict(list)
        for article in articles:
            category = article.get('category', 'Other')
            categorized[category].append(article)

        # Build HTML
        html = []

        # HTML header
        html.append("<!DOCTYPE html>")
        html.append("<html lang='en'>")
        html.append("<head>")
        html.append("<meta charset='UTF-8'>")
        html.append("<meta name='viewport' content='width=device-width, initial-scale=1.0'>")
        html.append(f"<title>{self.industry} News Brief - Categorized</title>")
        html.append("<style>")
        html.append(self._get_categorized_html_styles())
        html.append("</style>")
        html.append("</head>")
        html.append("<body>")

        # Content
        html.append("<div class='container'>")
        html.append(f"<h1>{self.industry} News Brief</h1>")
        html.append(f"<p class='meta'>Generated: {datetime.now().strftime('%B %d, %Y at %I:%M %p')} | Total Articles: {len(articles)}</p>")

        # Table of Contents
        html.append("<div class='toc'>")
        html.append("<h2>Categories</h2>")
        html.append("<ul>")
        for category in category_order:
            if category in categorized:
                count = len(categorized[category])
                html.append(f"<li><a href='#{category.replace(' ', '-').replace('&', 'and')}'>{category}</a> <span class='count'>({count})</span></li>")

        # Add "Other" category if it exists
        if "Other" in categorized:
            count = len(categorized["Other"])
            html.append(f"<li><a href='#Other'>{category}</a> <span class='count'>({count})</span></li>")

        html.append("</ul>")
        html.append("</div>")

        # Categorized Articles
        article_counter = 0
        for category in category_order:
            if category not in categorized:
                continue

            category_articles = categorized[category]
            category_id = category.replace(' ', '-').replace('&', 'and')

            html.append(f"<div class='category-section' id='{category_id}'>")
            html.append(f"<h2 class='category-title'>{category} <span class='category-count'>({len(category_articles)} articles)</span></h2>")

            for article in category_articles:
                article_counter += 1
                html.append(self._format_article_html_categorized(article, article_counter))

            html.append("</div>")

        # Add "Other" category if it exists
        if "Other" in categorized:
            category_articles = categorized["Other"]
            html.append(f"<div class='category-section' id='Other'>")
            html.append(f"<h2 class='category-title'>Other <span class='category-count'>({len(category_articles)} articles)</span></h2>")

            for article in category_articles:
                article_counter += 1
                html.append(self._format_article_html_categorized(article, article_counter))

            html.append("</div>")

        # Footer
        html.append("<footer>This categorized brief was automatically generated by the News Scraper</footer>")
        html.append("</div>")
        html.append("</body>")
        html.append("</html>")

        return "\n".join(html)

    def _format_article_html_categorized(self, article: Dict, index: int) -> str:
        """Format a single article in HTML for categorized brief"""
        html = []
        html.append("<div class='article'>")
        html.append(f"<h3>{index}. {article['title']}</h3>")
        html.append(f"<p class='meta'>Source: {article['source']} | Published: {article['published'].strftime('%b %d, %Y %I:%M %p')}</p>")
        html.append(f"<p>{article['description']}</p>")
        html.append(f"<a href='{article['link']}' target='_blank'>Read More →</a>")
        html.append("</div>")
        return "\n".join(html)

    def _get_categorized_html_styles(self) -> str:
        """Get CSS styles for categorized HTML output"""
        return """
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            line-height: 1.6;
            color: #333;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background: #f5f5f5;
        }
        .container {
            background: white;
            padding: 40px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        h1 {
            color: #2c3e50;
            border-bottom: 3px solid #3498db;
            padding-bottom: 10px;
        }
        h2 {
            color: #34495e;
            margin-top: 30px;
            border-bottom: 2px solid #ecf0f1;
            padding-bottom: 8px;
        }
        h3 {
            color: #2980b9;
        }
        .meta {
            color: #7f8c8d;
            font-size: 0.9em;
        }
        .toc {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 4px;
            margin: 20px 0;
        }
        .toc h2 {
            margin-top: 0;
            color: #2c3e50;
        }
        .toc ul {
            list-style-type: none;
            padding-left: 0;
        }
        .toc li {
            padding: 8px 0;
            border-bottom: 1px solid #ecf0f1;
        }
        .toc li:last-child {
            border-bottom: none;
        }
        .toc a {
            color: #2980b9;
            text-decoration: none;
            font-weight: 500;
        }
        .toc a:hover {
            text-decoration: underline;
        }
        .count {
            color: #7f8c8d;
            font-size: 0.9em;
        }
        .category-section {
            margin: 40px 0;
            padding: 20px 0;
        }
        .category-title {
            color: #2c3e50;
            font-size: 1.5em;
            border-bottom: 3px solid #3498db;
            padding-bottom: 10px;
            margin-bottom: 20px;
        }
        .category-count {
            color: #7f8c8d;
            font-size: 0.8em;
            font-weight: normal;
        }
        .article {
            margin: 20px 0;
            padding: 20px;
            background: #f8f9fa;
            border-left: 4px solid #3498db;
            border-radius: 4px;
        }
        .article h3 {
            margin-top: 0;
        }
        a {
            color: #3498db;
            text-decoration: none;
        }
        a:hover {
            text-decoration: underline;
        }
        footer {
            margin-top: 40px;
            padding-top: 20px;
            border-top: 1px solid #ecf0f1;
            text-align: center;
            color: #7f8c8d;
            font-size: 0.9em;
        }
        """

    def _generate_empty_brief(self, format_type: str = "markdown") -> str:
        """Generate a brief when no articles are found"""
        if format_type == "html":
            return f"<html><body><h1>No {self.industry} news found</h1></body></html>"
        elif format_type == "text":
            return f"No {self.industry} news found matching your criteria."
        else:
            return f"# {self.industry} News Brief\n\nNo news found matching your criteria."
